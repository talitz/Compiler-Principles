Chez Scheme Version 9.4.1
Copyright 1984-2016 Cisco Systems, Inc.

[1mComp171 - Ass3 Tests[0m
================================

Gilad Winterfeld Tests:
==============================================
1) (lambda () (if (lambda a (define x (lambda () x)) 8) (+ (- 9)) (lambda (x) (lambda () (set! x (+ 1 x (lambda (x) (lambda () x (set! x 1)))))))))
[1;32m Success! â˜º [0m 

2) (lambda (x) (lambda () (set! x (lambda (z) (lambda () z (set! z 1)))) x))
[1;32m Success! â˜º [0m 

3) (lambda (x) (lambda () y (set! x (+ 1 x (lambda (z) (lambda () z (set! z 1)))))))
[1;32m Success! â˜º [0m 

4) (lambda () (define (a b . c) 3) x)
[1;32m Success! â˜º [0m 

5) (lambda (x) x (set! x 1) (lambda (x) (lambda () x (set! x 1))))
[1;32m Success! â˜º [0m 

6) (lambda a (lambda b (define x 2) 2) #f)
[1;32m Success! â˜º [0m 

7) (lambda () (lambda () (lambda (x) (list (lambda () (lambda () x)) (lambda (x) (set! x 1))))))
[1;32m Success! â˜º [0m 

8) (or (+ 1) (or (+ 2) (+ 3)) (+ 4))
[1;32m Success! â˜º [0m 

9) ((lambda () 1) 2 3 4)
[1;32m Success! â˜º [0m 

10) (let ((a (let ((b 1)) (define b 2) b))) (define a 1) a)
[1;32m Success! â˜º [0m 

11) (lambda () (or (+ 1) (or (+ 2) (+ 3)) (+ 4)))
[1;32m Success! â˜º [0m 

12) (letrec ((a 1) (b 2) (c 3) (d 4)) (+ a b c d))
[1;32m Success! â˜º [0m 

13) (let ((a 1) (b 2) (c 3) (d 4)) (+ a b c d))
[1;32m Success! â˜º [0m 

14) (lambda () (define (a . b) a) 1)
[1;32m Success! â˜º [0m 

15) (let* ((a 1) (b 2) (c 3) (d 4)) (+ a b c d))
[1;32m Success! â˜º [0m 

16) ((lambda a a))
[1;32m Success! â˜º [0m 

17) ((lambda () (define x 1) x))
[1;32m Success! â˜º [0m 

18) (lambda () (define (a x) x) b)
[1;32m Success! â˜º [0m 

19) (lambda () (define x 1) (define (x) 2) (quote body))
[1;32m Success! â˜º [0m 

20) (lambda (a) (define p (lambda (ab) (define s 1) a)) b)
[1;32m Success! â˜º [0m 

21) (if (lambda (a . rr) (define a (lambda z (define z 1) 2)) 3) (+ (begin (+ 4) (lambda (c t) (define r 1) (define g 2) ((lambda () (quote hello)))))) (lambda () (or (+ 5) (+ (- 6)) (if (+ 6) (set! a (+ 4)) (or (+ 7) (+ (- 8)))))))
[1;32m Success! â˜º [0m 

22) (lambda a (define x 1) x)
[1;32m Success! â˜º [0m 

23) (lambda (a b) (define x 1) (lambda (a) (define a 4) (lambda a (define a 3) 1)))
[1;32m Success! â˜º [0m 

24) (lambda () (define a 1) (lambda () (define b 2) (quote body0)))
[1;32m Success! â˜º [0m 

25) (lambda (a . b) (define x 1) 1)
[1;32m Success! â˜º [0m 

26) (+ a b c (lambda a (+ a b c (lambda (a . b) (+ a b c (lambda (a) (+ a b c (lambda a (+ a b c (lambda (a . b) (+ a b c (lambda (a) (+ a b c)))))))))))))
[1;32m Success! â˜º [0m 

27) (lambda (x) (set! x 1) (lambda () (set! t (+ x 1))))
[1;32m Success! â˜º [0m 

28) ((lambda () (+ ((lambda () a)) ((lambda () b)) ((lambda () ((lambda () c)))))))
[1;32m Success! â˜º [0m 

29) (+ a b c (lambda (a b c) (+ a b c (lambda (a) (+ a b c (lambda (b) (+ a b c (lambda (c) (+ a b c (lambda (x) a b c))))))))))
[1;32m Success! â˜º [0m 

30) (lambda (a) (+ x a (lambda b (+ x a b (lambda (c . d) (+ x a b c d (lambda (e f g) (+ x a b c d e f g))))))))
[1;32m Success! â˜º [0m 

31) (+ 1 2 (lambda () (if (+ (- 1)) (if (+ (set! a (+ 1))) (or (+ 1) (+ 2)) (begin (+ 1) (lambda () (+ 2)) (+ 3))) (lambda a (+ a)))))
[1;32m Success! â˜º [0m 

32) (lambda x x (lambda (a b) (set! x 1)))
[1;32m Success! â˜º [0m 

33) (lambda x a (lambda (a b) (set! x 1)))
[1;32m Success! â˜º [0m 

34) (lambda (x) (lambda x x (set! x 1)))
[1;32m Success! â˜º [0m 

35) (lambda (x) x (lambda (a b) (set! x 1)))
[1;32m Success! â˜º [0m 

36) (lambda (x) (lambda (x) y (set! x 1)))
[1;32m Success! â˜º [0m 

37) (lambda (x) (lambda (x) y x (set! z 1)))
[1;32m Success! â˜º [0m 

38) (lambda (x . y) (lambda (x) y x (set! x 1)))
[1;32m Success! â˜º [0m 

39) (lambda (x y) (lambda () y x (set! x 1)))
[1;32m Success! â˜º [0m 

40) (define my-even? (lambda (e) (define even? (lambda (n) (or (zero? n) (odd? (- n 1))))) (define odd? (lambda (n) (and (positive? n) (even? (- n 1))))) (even? e)))
[1;32m Success! â˜º [0m 

41) (+ 1 2)
[1;32m Success! â˜º [0m 

42) (x (lambda (x) (x (lambda () (x (lambda () (x x)))))))
[1;32m Success! â˜º [0m 

43) (let ((a 0)) (list (lambda () a) (lambda () (set! a (+ a 1))) (lambda (b) (set! a b))))
[1;32m Success! â˜º [0m 

44) (define fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1))))))
[1;32m Success! â˜º [0m 

45) (lambda (a b) (lambda (c) (+ a b c)))
[1;32m Success! â˜º [0m 

46) (define fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1))))))
[1;32m Success! â˜º [0m 

47) (lambda (x) (x x))
[1;32m Success! â˜º [0m 

48) (lambda (f) ((lambda (x) (f (lambda s (apply (x x) s)))) (lambda (x) (f (lambda s (apply (x x) s))))))
[1;32m Success! â˜º [0m 

49) (x (lambda (x) (x (lambda () (x (lambda () (x x)))))))
[1;32m Success! â˜º [0m 


[1;32m"Gilad Winterfeld Tests" Tests: SUCCESS! â˜º [0m
 

Elad Zohar Tests:
==============================================
50) (define (test-1 val expr loc) (in-test-context! loc) (if ((test-postprocess) val) (test-ok loc expr) (test-error loc "~.s is false" expr)))
[1;32m Success! â˜º [0m 

51) (define (test-2 val1 expr1 val2 expr2 loc) (in-test-context! loc) (parameterize ((current-inspector (test-inspector))) (let ((val1 ((test-postprocess) val1)) (val2 ((test-postprocess) val2))) (if (equal? val1 val2) (test-ok loc expr1) (test-error loc "~.s: expected ~e, got ~e" expr1 val2 val1)))))
[1;32m Success! â˜º [0m 

52) (define (test-ok loc expr) (let ((s (tests-state))) (if (and (not (car loc)) (mpair? s)) (set-mcar! s (add1 (mcar s))) (printf "Test passed\n"))))
[1;32m Success! â˜º [0m 

53) (define (in-test-context! loc) (unless (or (car loc) (tests-state)) (error (quote test) "invalid use (not in `run-tests' or in the REPL)")))
[1;32m Success! â˜º [0m 

54) (define-syntax (test stx) (define context (syntax-local-context)) (define loc (list (eq? (quote top-level) context) (syntax-source stx) (syntax-line stx) (syntax-column stx) (syntax-position stx) (syntax-span stx))) (test-gen stx loc))
[1;32m Success! â˜º [0m 

55) (define (test-error loc fmt . args) (let ((s (tests-state)) (msg (parameterize ((current-inspector (test-inspector)) (print-struct #t)) (apply format fmt args))) (top? (car loc)) (loc (apply make-srcloc (cdr loc)))) (if (and (not top?) (mpair? s)) (begin (set-mcdr! s (cons (cons msg loc) (mcdr s))) (set-mcar! s (add1 (mcar s)))) (raise (make-exn:test (string-append "Test failure: " msg) (current-continuation-marks) (list loc))))))
[1;32m Success! â˜º [0m 

56) (define pattern-rule (lambda (pat handler) (lambda (e failure) (match pat e handler failure))))
[1;32m Success! â˜º [0m 

57) (define compose-patterns (letrec ((match-nothing (lambda (e failure) (failure))) (loop (lambda (s) (if (null? s) match-nothing (let ((match-rest (loop (cdr s))) (match-first (car s))) (lambda (e failure) (match-first e (lambda () (match-rest e failure))))))))) (lambda patterns (loop patterns))))
[1;32m Success! â˜º [0m 

58) (define read-stdin-to (lambda (end-of-input) (let ((end-of-input-list (string->list end-of-input))) (letrec ((state-init (lambda (seen) (let ((ch (read-char))) (cond ((eof-object? ch) (error (quote read-stdin-to) (format "Marker ~a not reached" end-of-input))) ((char=? ch (car end-of-input-list)) (state-seen seen (quasiquote ((unquote ch))) (cdr end-of-input-list))) (else (state-init (quasiquote ((unquote ch) (unquote-splicing seen))))))))) (state-seen (lambda (seen-before seen-now end-of-input-list-rest) (if (null? end-of-input-list-rest) (list->string (reverse seen-before)) (let ((ch (read-char))) (cond ((eof-object? ch) (format "Marker ~a not reached" end-of-input)) ((char=? ch (car end-of-input-list-rest)) (state-seen seen-before (quasiquote ((unquote ch) (unquote-splicing seen-now))) (cdr end-of-input-list-rest))) (else (state-init (quasiquote ((unquote ch) (unquote-splicing seen-now) (unquote-splicing seen-before))))))))))) (state-init (quote ()))))))
[1;32m Success! â˜º [0m 

59) (define ? (lambda (name . guards) (let ((guard? (lambda (e) (andmap (lambda (g?) (g? e)) guards)))) (lambda (value) (if (guard? value) (list value) #f)))))
[1;32m Success! â˜º [0m 

60) (define test (lambda (parser s) (parser s (lambda (e s) (quasiquote ((match (unquote e)) (remaining (unquote s))))) (lambda (w) (quasiquote (failed with report: (unquote-splicing w)))))))
[1;32m Success! â˜º [0m 

61) (define file->string (lambda (filename) (let ((input (open-input-file filename))) (letrec ((run (lambda () (let ((e (read-char input))) (if (eof-object? e) (begin (close-input-port input) (quote ())) (cons e (run))))))) (list->string (run))))))
[1;32m Success! â˜º [0m 

62) (define *transformer (lambda (^<p>) (unary (lambda (<p>) (^<p> <p>)))))
[1;32m Success! â˜º [0m 

63) (define test-string (lambda (parser string) (parser (string->list string) (lambda (e s) (quasiquote ((match (unquote e)) (remaining (unquote (list->string s)))))) (lambda (w) (quasiquote (failed with report: (unquote-splicing w)))))))
[1;32m Success! â˜º [0m 

64) (define *times (lambda (n) (unary (lambda (<p>) (times <p> n)))))
[1;32m Success! â˜º [0m 

65) (define not-followed-by (lambda (<p1> <p2>) (new (*parser <p1>) (*parser <p2>) *maybe (*caten 2) (*pack-with (lambda (e1 ?e2) (with ?e2 (lambda (found-e2? _) (quasiquote ((unquote e1) (unquote found-e2?))))))) (*guard (lambda (e1+found-e2?) (with e1+found-e2? (lambda (_ found-e2?) (not found-e2?))))) (*pack-with (lambda (e1 _) e1)) done)))
[1;32m Success! â˜º [0m 

66) (define *maybe (unary maybe))
[1;32m Success! â˜º [0m 

67) (define *otherwise (lambda (string) (unary (lambda (p) (otherwise p string)))))
[1;32m Success! â˜º [0m 

68) (define *caten (lambda (n) (nary caten n)))
[1;32m Success! â˜º [0m 

69) (define *disj (lambda (n) (nary disj n)))
[1;32m Success! â˜º [0m 

70) (define split-list (lambda (s n ret-s1+s2) (if (zero? n) (ret-s1+s2 (quote ()) s) (split-list (cdr s) (- n 1) (lambda (s1 s2) (ret-s1+s2 (cons (car s) s1) s2))))))
[1;32m Success! â˜º [0m 

71) (define nary (lambda (f-n-ary n) (lambda (ds cs) (split-list ds n (lambda (sgra ds) (continue (quasiquote ((unquote (apply f-n-ary (reverse sgra))) unquote ds)) cs))))))
[1;32m Success! â˜º [0m 

72) (define *fence (lambda (pred?) (unary (lambda (p) (fence p pred?)))))
[1;32m Success! â˜º [0m 

73) (define *guard (lambda (pred?) (unary (lambda (p) (fence p pred?)))))
[1;32m Success! â˜º [0m 

74) (define *pack (lambda (f) (unary (lambda (p) (pack p f)))))
[1;32m Success! â˜º [0m 

75) (define *pack-with (lambda (f) (unary (lambda (p) (pack-with p f)))))
[1;32m Success! â˜º [0m 

76) (define *plus (unary plus))
[1;32m Success! â˜º [0m 

77) (define *diff (binary diff))
[1;32m Success! â˜º [0m 

78) (define *swap (lambda (ds cs) (with ds (lambda (d1 d2 . ds) (continue (quasiquote ((unquote d2) (unquote d1) unquote ds)) cs)))))
[1;32m Success! â˜º [0m 

79) (define *star (unary star))
[1;32m Success! â˜º [0m 

80) (define binary (lambda (f-binary) (lambda (ds cs) (with ds (lambda (d2 d1 . ds) (continue (quasiquote ((unquote (f-binary d1 d2)) unquote ds)) cs))))))
[1;32m Success! â˜º [0m 

81) (define *dup (lambda (ds cs) (with ds (lambda (d1 . ds) (continue (quasiquote ((unquote d1) (unquote d1) unquote ds)) cs)))))
[1;32m Success! â˜º [0m 

82) (define unary (lambda (f-unary) (lambda (ds cs) (with ds (lambda (d . ds) (continue (quasiquote ((unquote (f-unary d)) unquote ds)) cs))))))
[1;32m Success! â˜º [0m 

83) (define *delayed (lambda (thunk) (lambda (ds cs) (continue (quasiquote ((unquote (delay thunk)) unquote ds)) cs))))
[1;32m Success! â˜º [0m 

84) (define done (lambda (ds cs) (with ds (lambda (parser . ds) (if (null? ds) parser (error (quote done) (format "The parser stack still contains ~a parsers!" (length ds))))))))
[1;32m Success! â˜º [0m 

85) (define *parser (lambda (p) (lambda (ds cs) (continue (quasiquote ((unquote p) unquote ds)) cs))))
[1;32m Success! â˜º [0m 

86) (define continue (lambda (ds cs) (with cs (lambda (c . cs) (c ds cs)))))
[1;32m Success! â˜º [0m 

87) (define new (lambda cs (continue (quote ()) cs)))
[1;32m Success! â˜º [0m 

88) (define <any> <any-char>)
[1;32m Success! â˜º [0m 

89) (define ^<separated-exprs> (lambda (<expr> <sep>) (new (*parser <expr>) (*parser <sep>) (*parser <expr>) (*caten 2) (*pack-with (lambda (_sep expr) expr)) *star (*caten 2) (*pack-with cons) done)))
[1;32m Success! â˜º [0m 

90) (define range-ci (^range char-ci<=?))
[1;32m Success! â˜º [0m 

91) (define <any-char> (const (lambda (ch) #t)))
[1;32m Success! â˜º [0m 

92) (define ^range (lambda (char<=?) (lambda (char-from char-to) (const (lambda (ch) (and (char<=? char-from ch) (char<=? ch char-to)))))))
[1;32m Success! â˜º [0m 

93) (define range (^range char<=?))
[1;32m Success! â˜º [0m 

94) (define one-of (^one-of char))
[1;32m Success! â˜º [0m 

95) (define one-of-ci (^one-of char-ci))
[1;32m Success! â˜º [0m 

96) (define word+suffixes-ci (^word+suffixes word-suffixes-ci))
[1;32m Success! â˜º [0m 

97) (define ^one-of (lambda (char) (lambda (word) (apply disj (map char (string->list word))))))
[1;32m Success! â˜º [0m 

98) (define ^word+suffixes (lambda (word-suffixes) (lambda (prefix suffix) (caten (word prefix) (word-suffixes suffix)))))
[1;32m Success! â˜º [0m 

99) (define word+suffixes (^word+suffixes word-suffixes))
[1;32m Success! â˜º [0m 

100) (define word-suffixes (^word-suffixes char))
[1;32m Success! â˜º [0m 

101) (define word-suffixes-ci (^word-suffixes char-ci))
[1;32m Success! â˜º [0m 

102) (define word-ci (^word char-ci))
[1;32m Success! â˜º [0m 

103) (define ^word-suffixes (lambda (char) (letrec ((loop (lambda (s) (if (null? s) <epsilon> (maybe (caten (char (car s)) (loop (cdr s)))))))) (lambda (suffix) (loop (string->list suffix))))))
[1;32m Success! â˜º [0m 

104) (define ^word (lambda (char) (lambda (word) (apply caten (map char (string->list word))))))
[1;32m Success! â˜º [0m 

105) (define word (^word char))
[1;32m Success! â˜º [0m 

106) (define char (^char char=?))
[1;32m Success! â˜º [0m 

107) (define char-ci (^char char-ci=?))
[1;32m Success! â˜º [0m 

108) (define otherwise (lambda (p message) (lambda (s ret-match ret-none) (p s ret-match (let ((marker (format "-->[~a]" (list->string (list-head s *marker-length*))))) (lambda (w) (ret-none (quasiquote ((unquote-splicing w) (unquote message) (unquote marker))))))))))
[1;32m Success! â˜º [0m 

109) (define ^char (lambda (char=?) (lambda (character) (const (lambda (ch) (char=? ch character))))))
[1;32m Success! â˜º [0m 

110) (define maybe->value (lambda (?result) (cadr ?result)))
[1;32m Success! â˜º [0m 

111) (define fence (lambda (p pred?) (lambda (s ret-match ret-none) (p s (lambda (e s) (if (pred? e) (ret-match e s) (ret-none (quote ())))) ret-none))))
[1;32m Success! â˜º [0m 

112) (define maybe (lambda (p) (lambda (s ret-match ret-none) (p s (lambda (e s) (ret-match (quasiquote (#t (unquote e))) s)) (lambda (w) (ret-match (quasiquote (#f #f)) s))))))
[1;32m Success! â˜º [0m 

113) (define maybe? (lambda (?result) (car ?result)))
[1;32m Success! â˜º [0m 

114) (define pack-with (lambda (p f) (lambda (s ret-match ret-none) (p s (lambda (e s) (ret-match (apply f e) s)) ret-none))))
[1;32m Success! â˜º [0m 

115) (define diff (lambda (p1 p2) (lambda (s ret-match ret-none) (p1 s (lambda (e w) (p2 s (lambda _ (ret-none (quote ()))) (lambda (w1) (ret-match e w)))) ret-none))))
[1;32m Success! â˜º [0m 

116) (define times (lambda (<p> n) (if (zero? n) <epsilon> (pack-with (caten <p> (times <p> (- n 1))) cons))))
[1;32m Success! â˜º [0m 

117) (define pack (lambda (p f) (lambda (s ret-match ret-none) (p s (lambda (e s) (ret-match (f e) s)) ret-none))))
[1;32m Success! â˜º [0m 

118) (define star (lambda (p) (disj (pack-with (caten p (delay (lambda () (star p)))) cons) <epsilon>)))
[1;32m Success! â˜º [0m 

119) (define plus (lambda (p) (pack-with (caten p (star p)) cons)))
[1;32m Success! â˜º [0m 

120) (define disj (letrec ((binary-disj (lambda (p1 p2) (lambda (s ret-match ret-none) (p1 s ret-match (lambda (w1) (p2 s ret-match (lambda (w2) (ret-none (quasiquote ((unquote-splicing w1) (unquote-splicing w2))))))))))) (loop (lambda (ps) (if (null? ps) <fail> (binary-disj (car ps) (loop (cdr ps))))))) (lambda ps (loop ps))))
[1;32m Success! â˜º [0m 

121) (define delay (lambda (thunk) (lambda (s ret-match ret-none) ((thunk) s ret-match ret-none))))
[1;32m Success! â˜º [0m 

122) (define caten (letrec ((binary-caten (lambda (p1 p2) (lambda (s ret-match ret-none) (p1 s (lambda (e1 s) (p2 s (lambda (e2 s) (ret-match (cons e1 e2) s)) ret-none)) ret-none)))) (loop (lambda (ps) (if (null? ps) <epsilon> (binary-caten (car ps) (loop (cdr ps))))))) (lambda ps (loop ps))))
[1;32m Success! â˜º [0m 

123) (define <fail> (lambda (s ret-match ret-none) (ret-none (quote ()))))
[1;32m Success! â˜º [0m 

124) (define const (lambda (pred?) (lambda (s ret-match ret-none) (cond ((null? s) (ret-none (quote ()))) ((pred? (car s)) (ret-match (car s) (cdr s))) (else (ret-none (quote ())))))))
[1;32m Success! â˜º [0m 

125) (define <epsilon> (lambda (s ret-match ret-none) (ret-match (quote ()) s)))
[1;32m Success! â˜º [0m 

126) (define list-head (lambda (s n) (cond ((null? s) (quote ())) ((zero? n) (quote (#\space #\e #\t #\c))) (else (cons (car s) (list-head (cdr s) (- n 1)))))))
[1;32m Success! â˜º [0m 

127) (define <end-of-input> (lambda (s ret-match ret-none) (if (null? s) (ret-match #t (quote ())) (ret-none (quote ())))))
[1;32m Success! â˜º [0m 

128) (define const-pair? (lambda (e) (and (quote? e) (pair? (cadr e)))))
[1;32m Success! â˜º [0m 

129) (define expand-qq (letrec ((expand-qq (lambda (e) (cond ((unquote? e) (cadr e)) ((unquote-splicing? e) (error (quote expand-qq) "unquote-splicing here makes no sense!")) ((pair? e) (let ((a (car e)) (b (cdr e))) (cond ((unquote-splicing? a) (quasiquote (append (unquote (cadr a)) (unquote (expand-qq b))))) ((unquote-splicing? b) (quasiquote (cons (unquote (expand-qq a)) (unquote (cadr b))))) (else (quasiquote (cons (unquote (expand-qq a)) (unquote (expand-qq b)))))))) ((vector? e) (quasiquote (list->vector (unquote (expand-qq (vector->list e)))))) ((or (null? e) (symbol? e)) (quasiquote (quote (unquote e)))) (else e)))) (optimize-qq-expansion (lambda (e) (optimizer e (lambda () e)))) (optimizer (compose-patterns (pattern-rule (quasiquote (append (unquote (? (quote e))) (quote ()))) (lambda (e) (optimize-qq-expansion e))) (pattern-rule (quasiquote (append (unquote (? (quote c1) const-pair?)) (cons (unquote (? (quote c2) const?)) (unquote (? (quote e)))))) (lambda (c1 c2 e) (let ((c (quotify (quasiquote ((unquote-splicing (unquotify c1)) (unquote (unquotify c2)))))) (e (optimize-qq-expansion e))) (optimize-qq-expansion (quasiquote (append (unquote c) (unquote e))))))) (pattern-rule (quasiquote (append (unquote (? (quote c1) const-pair?)) (unquote (? (quote c2) const-pair?)))) (lambda (c1 c2) (let ((c (quotify (append (unquotify c1) (unquotify c2))))) c))) (pattern-rule (quasiquote (append (unquote (? (quote e1))) (unquote (? (quote e2))))) (lambda (e1 e2) (let ((e1 (optimize-qq-expansion e1)) (e2 (optimize-qq-expansion e2))) (quasiquote (append (unquote e1) (unquote e2)))))) (pattern-rule (quasiquote (cons (unquote (? (quote c1) const?)) (cons (unquote (? (quote c2) const?)) (unquote (? (quote e)))))) (lambda (c1 c2 e) (let ((c (quotify (list (unquotify c1) (unquotify c2)))) (e (optimize-qq-expansion e))) (optimize-qq-expansion (quasiquote (append (unquote c) (unquote e))))))) (pattern-rule (quasiquote (cons (unquote (? (quote e1))) (unquote (? (quote e2))))) (lambda (e1 e2) (let ((e1 (optimize-qq-expansion e1)) (e2 (optimize-qq-expansion e2))) (if (and (const? e1) (const? e2)) (quotify (cons (unquotify e1) (unquotify e2))) (quasiquote (cons (unquote e1) (unquote e2)))))))))) (lambda (e) (optimize-qq-expansion (expand-qq e)))))
[1;32m Success! â˜º [0m 

130) (define quotify (lambda (e) (if (or (null? e) (pair? e) (symbol? e) (vector? e)) (quasiquote (quote (unquote e))) e)))
[1;32m Success! â˜º [0m 

131) (define unquotify (lambda (e) (if (quote? e) (cadr e) e)))
[1;32m Success! â˜º [0m 

132) (define ^quote? (lambda (tag) (lambda (e) (and (pair? e) (eq? (car e) tag) (pair? (cdr e)) (null? (cddr e))))))
[1;32m Success! â˜º [0m 

133) (define const? (let ((simple-sexprs-predicates (list boolean? char? number? string?))) (lambda (e) (or (ormap (lambda (p?) (p? e)) simple-sexprs-predicates) (quote? e)))))
[1;32m Success! â˜º [0m 


[1;32m"Elad Zohar Tests" Tests: SUCCESS! â˜º [0m
 

Comp161 Ass3 Tests:
==============================================
134) (lambda (a) (begin (define b (+ 87 a))) b)
[1;32m Success! â˜º [0m 

135) (lambda (a) (define b 6) b)
[1;32m Success! â˜º [0m 

136) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) 4)) (ff 5))) (ff b))
[1;32m Success! â˜º [0m 

137) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c t)))) (u t))) (ff 5)) (ff b)))
[1;32m Success! â˜º [0m 

138) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) (- t g))) 5) (* a (ff b) b a)))
[1;32m Success! â˜º [0m 

139) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) (- t g))) (ff 5))) (ff b))
[1;32m Success! â˜º [0m 

140) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) (- t g))) (begin (begin (begin (define x a)) (define xx b) (define xxx (* b b))))) (begin (define xxxx c) (define tt (lambda (d) (begin (define t 8) (* t 7)))) (* x xx (ff c) (tt xxxx) b a))))
[1;32m Success! â˜º [0m 

141) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) (- t g))) (begin (begin (begin (define x a)) (define xx b) (define xxx (* b b)) (define t1 (lambda (x) (define t2 (lambda (x) (define t3 (lambda (x) (define t4 (lambda (x) x)) (- 5 (t4 x)))) (+ x (t3 7)))) (- (t2 a) a)))))) (begin (define xxxx c) (define tt (lambda (d) (begin (define t 8) (* t 7)))) (* x (t1 xx) (ff c) (tt xxxx) b a))))
[1;32m Success! â˜º [0m 

142) (lambda (a b c) (begin (begin (begin (begin (begin (define x a)) (define xx b) (define xxx (* b b))))) (begin (define xxxx c) (* x xx xxx xxxx b a))))
[1;32m Success! â˜º [0m 

143) (lambda (a b c) (begin (begin (begin (begin (begin (define x a)) (define xx b) (define xxx (* b b))))) (begin (define xxxx c) (define tt (lambda (d) (begin (define t 8) (* t 7)))) (* x xx xxx (tt xxxx) b a))))
[1;32m Success! â˜º [0m 

144) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (begin (define f (lambda (d) (* d d (foo d)))) (begin (define h (lambda (f g) (define or_p (lambda (x y) (or (even? x) (even? y) (even (+ x y))))) (define t6 (lambda (x) (begin (define a1 1) (define a2 2) (* 2 (+ a1 a2))))) (if (or_p f g) f (t6 g))))))) (* (foo (goo (h a x))) (f (* b (f c)))))
[1;32m Success! â˜º [0m 

145) (lambda (a b c) (begin (begin (begin (begin (begin (define x a)) (define xx b) (define xxx (* b b))))) (* x xx xxx b a)))
[1;32m Success! â˜º [0m 

146) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (define t5 (lambda (x) (begin (define x 6) (* a x)))) (begin (define f (lambda (d) (* d d d))) (begin (define h (lambda (f g) (if (or (even? g) (even? g) (even (+ f g))) f g)))))) (* (foo (goo (* a x))) (f (* b c))))
[1;32m Success! â˜º [0m 

147) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (define t5 (lambda (x) (begin (define x 6) (* a x)))) (begin (define f (lambda (d) (* d d (t5 d)))) (begin (define h (lambda (f g) (define or_p (lambda (x y) (or (even? x) (even? y) (even (+ x y))))) (define t6 (lambda (x) (begin (define a1 1) (define a2 2) (* 2 (+ a1 a2))))) (if (or_p f g) f (t6 g))))))) (* (foo (goo (h a x))) (f (* b (t5 c)))))
[1;32m Success! â˜º [0m 

148) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (define j 34) (begin (define moo (lambda (x) (begin (define x 10) (define y (lambda (x) (not x))) (set! a (* a b c)))))) (* (foo (goo (moo x))) (goo (* b c j)))))
[1;32m Success! â˜º [0m 

149) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b)))))) (* (foo (goo (* a x))) (goo (* b c))))
[1;32m Success! â˜º [0m 

150) (lambda (a) (begin (begin (define force (lambda (x) (+ x x))) (define the (lambda (y) (* y y))) (define with (lambda (x) (- x 4)))) (begin (define may (lambda (x) (+ x x))) (define be (lambda (y) (* 5 y)))) (define you a)) (may (the (force (be (with you))))))
[1;32m Success! â˜º [0m 

151) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (begin (define moo (lambda (x) (begin (define x 10) (define y (lambda (x) (not x))) (set! a (* a b c)))))) (* (foo (goo (moo x))) (goo (* b c)))))
[1;32m Success! â˜º [0m 

152) (lambda (a) (define min4 (lambda (a) (define min3 (lambda (a) (define min2 (lambda (a) (- a 2))) (- (min2 a) 1))) (- (min3 a) 1))) (+ (min4 a) a))
[1;32m Success! â˜º [0m 

153) (lambda (t i) (begin (begin (define l (lambda (x) (+ x x))) (define o (lambda (y) (* y y)))) (begin (define v (lambda (x) (+ x x))) (define e (lambda (y) (- y))))) (* i t))
[1;32m Success! â˜º [0m 

154) (lambda (a b) (begin (define iszero (or (zero? a) (zero? b))) (define id1 (lambda (a b) a))) (if iszero 3 5))
[1;32m Success! â˜º [0m 

155) (lambda (a b) (begin (define iszero (lambda (a b) (or (zero? a) (zero? b)))) (define min1 (lambda (a) (- a 1))) (define min2 (lambda (b) (- b 2)))) (if (iszero a b) (min1 a) (min2 b)))
[1;32m Success! â˜º [0m 

156) (lambda (a) (begin (define a 4) (define id1 (lambda (a b) a))) (* a a))
[1;32m Success! â˜º [0m 

157) (lambda (a) (begin (define a 4) (define id1 (lambda (a b) a))) (* (id1 a a) a))
[1;32m Success! â˜º [0m 

158) (lambda (x) (begin (define y 10) (if (even? x) y (- y x))))
[1;32m Success! â˜º [0m 

159) (lambda (x) (begin (define y 10) (set! x (* x x)) (if (even? x) y (- y x))))
[1;32m Success! â˜º [0m 

160) (lambda (a) (define id (lambda (b) b)) (define min1 (lambda (b) (- b 1))) (min1 (id a)))
[1;32m Success! â˜º [0m 

161) (lambda (a b c) (define plus (lambda (a b) (+ a b))) (define minus (lambda (a b) (- a b))) (minus (plus a b) c))
[1;32m Success! â˜º [0m 

162) (lambda (a) (define a 5) a)
[1;32m Success! â˜º [0m 

163) (lambda (a) (define add5 (lambda (b) (+ b 5))) (add5 a))
[1;32m Success! â˜º [0m 

164) (lambda (a) (set! min4 (lambda (a) (set! min3 (lambda (a) (set! min2 (lambda (a) (- a 2))) (- (min2 a) 1))) (- (min3 a) 1))) (+ (min4 a) a))
[1;32m Success! â˜º [0m 

165) (test (lambda (x) (x (lambda (y x) (x (lambda (y) (x (lambda (y) y) test)))))) zero?)
[1;32m Success! â˜º [0m 

166) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) (- t g))) 5) (* a (ff b) b a)))
[1;32m Success! â˜º [0m 

167) (lambda (x y) (list (lambda () x) (lambda (z) (set! y z)) (lambda (z) (set! x z))))
[1;32m Success! â˜º [0m 

168) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (define t5 (lambda (x) (begin (define x 6) (* a x)))) (begin (define f (lambda (d) (* d d (t5 d)))) (begin (define h (lambda (f g) (define or_p (lambda (x y) (or (even? x) (even? y) (even (+ x y))))) (define t6 (lambda (x) (begin (define a1 1) (define a2 2) (* 2 (+ a1 a2))))) (if (or_p f g) f (t6 g))))))) (+ (t5 6) (t6 7) (f 6)))
[1;32m Success! â˜º [0m 

169) (lambda (x) (lambda (y) (lambda (x) ((lambda (z) (x y y)) x))))
[1;32m Success! â˜º [0m 

170) (lambda (x y z zx xx) (begin (define t1 (lambda (g t) (if (zero? y) zx (g t z)))) (define y (lambda (y x) (+ y x))) (define g (lambda (y f) (y f)))) (t1 (y z g) g))
[1;32m Success! â˜º [0m 

171) (lambda (x) (begin (define a (lambda (x y z) (begin (set! z z) (set! z x)) (x y z))) (define b b) (define c (lambda (y) (lambda (z) (z x y)))) (b y)) (x b y a))
[1;32m Success! â˜º [0m 

172) (lambda (x y z zx xx) (begin (define y (+ x 5)) (set! y 8) xx) (if (zero? y) zx))
[1;32m Success! â˜º [0m 

173) (lambda (x y z zx xx) (begin (define t1 (lambda (g t) (if (zero? y) zx (g t z))))) t1)
[1;32m Success! â˜º [0m 

174) (lambda (we) (if (are? all) (free vars)))
[1;32m Success! â˜º [0m 

175) (lambda (x xx) (set! x xx) (- xxx x))
[1;32m Success! â˜º [0m 

176) ((lambda (x) (x (lambda (y) (x (lambda (y) (x (lambda (y) y))))))))
[1;32m Success! â˜º [0m 

177) (lambda (x y) (x (y 6)))
[1;32m Success! â˜º [0m 

178) (lambda (x y z) (define x 5) (+ x y z))
[1;32m Success! â˜º [0m 

179) (x (lambda (y) (begin (define a (lambda (b) (y b))) (define t (lambda (x) (begin (define h (lambda (j) (x j y))) h))) (t a))))
[1;32m Success! â˜º [0m 

180) (lambda (x y) (+ x y))
[1;32m Success! â˜º [0m 

181) (lambda (y) (x y))
[1;32m Success! â˜º [0m 

182) (lambda (x) x)
[1;32m Success! â˜º [0m 

183) (lambda (x) x x x)
[1;32m Success! â˜º [0m 

184) (define x (lambda (x) (lambda () (set! x 5) x)))
[1;32m Success! â˜º [0m 

185) (let ((counter 0)) (set! inc-counter-by (lambda (n) (set! counter (+ counter n)))) (set! inc-counter (lambda () (inc-counter-by 1))) (set! counter-value (lambda () counter)))
[1;32m Success! â˜º [0m 

186) (define list-of-values (lambda (list-of-values) (lambda (exps env) (if (no-operands? exps) (quote ()) (cons (env-eval (first-operand exps) env) (list-of-values (rest-operands exps) env))) (set! list-of-values (cdr list-of-values)))))
[1;32m Success! â˜º [0m 

187) (define (add-binding! binding) (add-binding-to-frame! binding (first-frame the-global-environment)))
[1;32m Success! â˜º [0m 

188) (define make-sq-jump (lambda (lst) (letrec ((main-func (lambda (make-sq-jump res-lst) (lambda (a) (set! make-sq-jump make-sq-jump) (set! res-lst res-lst) (if (null? (cdr (memq a lst))) (list lst) (let ((res-lst (make-sq-jump (cdr (memq a lst))))) (append (list (append (list a) (filter (lambda (res-lst-element) (> (car res-lst-element) (* a a))) res-lst))) res-lst))))))) (main-func (car lst)))))
[1;32m Success! â˜º [0m 

189) (define primitive-application? (lambda (primitive-application?) ((lambda (app) (primitive-application? (car app)) (set! primitive-application? primitive-application?)))))
[1;32m Success! â˜º [0m 

190) (set! are-parentheses-balanced-list? (lambda (are-parentheses-balanced-list?) (lambda (exp num) (set! are-parentheses-balanced-list? are-parentheses-balanced-list?) (if (and (= num 0) (null? exp)) #t (if (or (< num 0) (null? exp)) #f (if (char=? (car exp) #\() (are-parentheses-balanced-list? (cdr exp) (+ num 1)) (if (char=? (car exp) #\)) (are-parentheses-balanced-list? (cdr exp) (- num 1)) (are-parentheses-balanced-list? (cdr exp) num))))))))
[1;32m Success! â˜º [0m 

191) (define make-monitored (lambda (proc) (letrec ((counter 0) (how-many-calls (lambda () counter)) (reset-count (lambda () (set! counter 0))) (compute (lambda (arg) (begin (set! counter (+ counter 1)) (proc arg)))) (dispatch (lambda (op arg) (cond ((eq? op (quote how-many-calls?)) (how-many-calls)) ((eq? op (quote reset-count)) (reset-count)) ((eq? op (quote compute)) (compute arg)) (else 0))))) dispatch)))
[1;32m Success! â˜º [0m 

192) (lambda (a b c d e) (define f (lambda (x) (a (b c) (c b d) (a (b (c (d e))))))) (set! a 3) (set! b 5) (set! c a) #f)
[1;32m Success! â˜º [0m 

193) (define cse (lambda (exp) (let* ((res_aux (aux exp (quote ()))) (res_let (make_let (car res_aux) (cadr res_aux) (quote ()) 1))) (if (null? (cadr res_let)) exp (let ((let_ribs (filter (lambda (x) x) (map (lambda (rib) (find (car rib) (cadr res_let))) (cadr res_aux))))) (list (quote let*) let_ribs (car res_let)))))))
[1;32m Success! â˜º [0m 

194) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (set! foo 4) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (define t5 (lambda (x) (begin (define x 6) (set! goo 5) (set! f 50) (* a x)))) (begin (define f (lambda (d) (* d d d))) (begin (define h (lambda (f g) (if (or (even? g) (even? g) (even (+ f g))) f g)))))) (* (foo (goo (* a x))) (f (* b c))))
[1;32m Success! â˜º [0m 

195) (x (lambda (y) (begin (define a (lambda (b) (define a (lambda (b) b)) (set! a (lambda (b) b)) (set! t (lambda (b) b)) (set! h (lambda (b) b)) (y b))) (define t (lambda (t) (begin (define h (lambda (j) (define y 7) (t j y))) h))) (t (a h)))))
[1;32m Success! â˜º [0m 

196) (lambda (a b) (begin (define iszero (lambda (a b) (or (zero? a) (zero? b)))) (define min1 (lambda (a) (- a 1))) (define min2 (lambda (b) (- (min1 b) 2)))) (if (iszero a b) (min1 a) (min2 b)))
[1;32m Success! â˜º [0m 

197) (lambda (t i) (begin (begin (define l (lambda (x) (+ x x))) (define o (lambda (y) (* i t)))) (begin (define i (lambda (x) (+ x x))) (define e (lambda (y) (- y))))) (* i t))
[1;32m Success! â˜º [0m 

198) (lambda (x) (begin (define y 10) (set! x (* x x)) (if (even? x) y (- y x))))
[1;32m Success! â˜º [0m 

199) (lambda (a) (begin (define a 4) (define id1 (lambda (c b) a))) (* a a))
[1;32m Success! â˜º [0m 

200) (lambda (x y) (+ y 2) (set! y 2) (lambda (z) (set! x x)))
[1;32m Success! â˜º [0m 

201) (define foo (lambda (x) (begin (define (poo x y) (goo (boo x y))) (define (moo x) (* x x x)) (set! x (goo x)) (set! x (boo x)) (poo x (moo x)))))
[1;32m Success! â˜º [0m 

202) (lambda (x) (lambda (z) (set! x x)))
[1;32m Success! â˜º [0m 

203) (lambda (x y) (lambda (z) (set! x x) (set! y 2)))
[1;32m Success! â˜º [0m 

204) (lambda (x) (set! x 6) (set! x 6) (set! x 6) (set! x 6) (lambda (y) x))
[1;32m Success! â˜º [0m 

205) (lambda (x z) (begin (define a (lambda (g y) (begin (set! z z) (set! x z)) (x y z))) (define b b) (define c (lambda (f) (lambda (g) (z x y)))) (b y)) (x b y a))
[1;32m Success! â˜º [0m 

206) (lambda (x y z zx xx) (begin (define t1 (lambda (g t) (if (zero? y) zx (g t z)))) (define y (lambda (y x) (+ y x))) (define g (lambda (y f) (y f)))) (set! y x) (t1 (y z g) g))
[1;32m Success! â˜º [0m 

207) (lambda (x) (set! x 6) (lambda (y) x))
[1;32m Success! â˜º [0m 

208) (x (lambda (y) (begin (set! a (lambda (b) (y b))) (set! t (lambda (x) (begin (set! y (lambda (j) (x j x))) h))) (y a))))
[1;32m Success! â˜º [0m 

209) (lambda (x) (x (lambda (y) (x (lambda (y) (x (lambda (y) (set! x y))))))))
[1;32m Success! â˜º [0m 

210) (lambda (x y z) (lambda (y) ((set! x 5)) (+ x y)) (+ x y z))
[1;32m Success! â˜º [0m 

211) (lambda (x y z) (lambda (y) ((set! x 5) (set! y 6) (+ x y)) (+ x y z)))
[1;32m Success! â˜º [0m 

212) (a b)
[1;32m Success! â˜º [0m 

213) (lambda (x) (list (lambda (y) (set! x 1)) x))
[1;32m Success! â˜º [0m 

214) (define factorial (lambda (n) (if (= n 0) 1 (* n (factorial (- n 1))))))
[1;32m Success! â˜º [0m 

215) (lambda (a b c) (begin (begin (begin (define foo (lambda (x) (+ x x))) (define goo (lambda (y) (define foo (* a b)) (* foo b))))) (define j 34) (begin (define moo (lambda (x) (begin (define x 10) (define y (lambda (x) (not x))) (set! a (* a b c)))))) (* (foo (goo (moo x))) (goo (* b c j)))))
[1;32m Success! â˜º [0m 

216) (let ((fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))) (fact 5))
[1;32m Success! â˜º [0m 

217) (letrec ((first 1) (second 2) (third 3) (fourth (lambda (x) (if (> x 0) (begin (+ 1 first) (+ 1 second) (newline) (fourth (- x 1))) 1)))) (fourth (fourth 2)))
[1;32m Success! â˜º [0m 

218) (define fibonacci (memoize (lambda (n) (if (< n 2) 1 (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))
[1;32m Success! â˜º [0m 

219) ((lambda (c) (+ c 5)) 7)
[1;32m Success! â˜º [0m 

220) (lambda (a) (set! min4 (lambda (a) (set! min3 (lambda (a) (set! min2 (lambda (a) (- a 2))) (- (min2 a) 1))) (- (min3 a) 1))) (+ (min4 a) a))
[1;32m Success! â˜º [0m 

221) (lambda (c) (define f2 (lambda (x) (+ x x (c x)))) (if (not (eq? c 0)) (try that) (f2 (f2 c))))
[1;32m Success! â˜º [0m 

222) (lambda (a b c) (begin (begin (define ff (lambda (g) (begin (define t (+ 6 g)) (define u (lambda (c) (* c (t c))))) (- t g))) 5) (* a (ff b) (b a))))
[1;32m Success! â˜º [0m 

223) (lambda (a b c d e) (a (b c) (c b d) (a (b (c (d e))))))
[1;32m Success! â˜º [0m 

224) (lambda (x y z zx xx) (begin (define t1 (lambda (g t) (if (zero? y) zx (g t z)))) (define y (lambda (y x) (+ y x))) (define g (lambda (y f) (y f)))) (t1 (y z g) g))
[1;32m Success! â˜º [0m 

225) (lambda (x) (begin (define a (lambda (x y z) (begin (set! z z) (set! z x)) (x y z))) (define b b) (define c (lambda (y) (lambda (z) (z x y)))) (b y)) (x b y a))
[1;32m Success! â˜º [0m 

226) (lambda (a) (begin (define b (lambda (x) (+ x a))) (define c (lambda (x) (x a))) (c (b a))))
[1;32m Success! â˜º [0m 

227) (x (lambda (y) (begin (define a (lambda (b) (y b))) (define t (lambda (x) (begin (define h (lambda (j) (x j y))) h))) (t a))))
[1;32m Success! â˜º [0m 

228) (lambda (a b) (a (a b)))
[1;32m Success! â˜º [0m 

229) (lambda (a) (if (b? a) (- a 1) (b a)))
[1;32m Success! â˜º [0m 

230) (lambda (a) (a 2))
[1;32m Success! â˜º [0m 

231) (lambda (a b) (a (b 2)))
[1;32m Success! â˜º [0m 


[1;32m"Comp161 Ass3 Tests" Tests: SUCCESS! â˜º [0m
 

Complex Tests:
==============================================
232) (lambda (a b . x) 1)
[1;32m Success! â˜º [0m 

233) (lambda (a b c) (begin (begin (define foo (lambda (x) x)) (define goo (lambda (y) y))) (begin (define moo (lambda (x) x)) (define poo (lambda (y) y)))) (* (foo (poo (moo a))) (goo (* b c))))
[1;32m Success! â˜º [0m 

234) (lambda (x) (set! x 3) (+ x 4))
[1;32m Success! â˜º [0m 

235) (lambda (a b c d e f g h i j k lmnop q r stuv w . xyz) xyz (lambda (k j) ((lambda () j) k)) (i h) g f free-var1 (e d c b ((((a))))))
[1;32m Success! â˜º [0m 

236) (cond ((a 1) b) ((= ((lambda a 2) (list 2)) 3) (caddr a)) (else (car x)))
[1;32m Success! â˜º [0m 

237) ((lambda (a) (lambda x (lambda (g . h) (let ((h 15)) h)))) a x g)
[1;32m Success! â˜º [0m 

238) (begin (begin 5) (begin (display "abcde") (+ 6 7)) #t #f (display "Lorem Ipsum"))
[1;32m Success! â˜º [0m 

239) (let () (define x 5) (a (let ((a 1)) (set! a 2) (- 3 a))) (- b a) (c))
[1;32m Success! â˜º [0m 

240) (let () (let () (let () (f ((lambda () (let () ((lambda x (f (lambda (g h . k) x)))) 1)))))))
[1;32m Success! â˜º [0m 

241) (* (* 1 2) 3 (+ 4 5) ((lambda () (/ 7 8))) ((lambda () (define nine 9) (- nine 10))))
[1;32m Success! â˜º [0m 

242) (apply f (1 2 3))
[1;32m Success! â˜º [0m 

243) (a (lambda (a) (a (lambda (b) (a b (lambda (a) (a b (lambda (c) (a b c)))))))))
[1;32m Success! â˜º [0m 

244) (define x (+ 1 (* 3 4) (- 5 6)))
[1;32m Success! â˜º [0m 

245) (lambda (a) (lambda () (set! a 3) b))
[1;32m Success! â˜º [0m 

246) (lambda (a) (set! a 3) a)
[1;32m Success! â˜º [0m 

247) (lambda (x . y) (lambda () (set! x 1)))
[1;32m Success! â˜º [0m 

248) (or 1 (lambda (x) (x x)) (lambda (y) (y y)))
[1;32m Success! â˜º [0m 

249) (lambda (x) (lambda () (set! x 1)))
[1;32m Success! â˜º [0m 

250) (lambda x (lambda () (set! x 1)))
[1;32m Success! â˜º [0m 

251) (or 3 4 (lambda (x) (define x 3) 5))
[1;32m Success! â˜º [0m 

252) (lambda (a) a (lambda (b c) (set! a 4) (+ a b) (lambda () (set! b 8))))
[1;32m Success! â˜º [0m 

253) (((lambda () f)) ((lambda () g)) ((lambda () h)) (z (m c (d ((lambda () ((lambda () ((lambda () ((lambda () ((lambda () ((lambda () ((lambda () (+)))))))))))))))))))
[1;32m Success! â˜º [0m 

254) (lambda (x) (lambda (y) (set! x 1) (lambda () x)))
[1;32m Success! â˜º [0m 

255) (lambda (x) (x x))
[1;32m Success! â˜º [0m 

256) ((lambda () ((lambda () ((lambda () ((lambda () ((lambda () ((lambda () ((lambda () (+)))))))))))))))
[1;32m Success! â˜º [0m 

257) (lambda (f) ((lambda (x) (f (lambda s (apply (x x) s)))) (lambda (x) (f (lambda s (apply (x x) s))))))
[1;32m Success! â˜º [0m 

258) (x (lambda (x) (x (lambda () (x (lambda () (x x)))))))
[1;32m Success! â˜º [0m 

259) ((lambda () 5))
[1;32m Success! â˜º [0m 

260) (lambda (x) (x x) (display "asaf"))
[1;32m Success! â˜º [0m 

261) (begin (a (a (b (c 2) d))) (f 1) (g 2) (z) 1 (h 3) (a (a (b (c 2) d))))
[1;32m Success! â˜º [0m 

262) (((lambda (a b c d) (begin (a (a (b (c 2) d))) (f 1) (g 2) (z) 1 (h 3) (a (a (b (c 2) ((lambda () ((lambda () d)))))))))))
[1;32m Success! â˜º [0m 

263) (and (a (a (b (c 2) d))) (f (f 1)) (a (a (b (c 2) d))) (g 2) (z) 1 (h 3) (a (a (b (c 2) d))))
[1;32m Success! â˜º [0m 

264) (let ((a 1)) (and (a (a (b (c 2) d))) (f (f 1)) (a (a (b (c 2) d))) (g 2) (z) 1 (h 3) (a (a (b (c 2) d)))))
[1;32m Success! â˜º [0m 

265) (lambda (a) (or (f 1) (f (f 1)) (a (a (b (c 2) d))) (g 2) (z) 1 (h 3) (a (a (b (c 2) d)))))
[1;32m Success! â˜º [0m 

266) (lambda (a) (or (f 1) (f (f 1)) (a (a (b (c 2) d))) (g 2) (z) 1 (h 3) (a (a (b (c 2) d)))) (a (b 1)))
[1;32m Success! â˜º [0m 

267) (set! x (f 1))
[1;32m Success! â˜º [0m 

268) (or (f 1) (f (f 1)) (a (a (b (c 2) d))) (g 2) (z) 1 (h 3) (a (a (b (c 2) d))))
[1;32m Success! â˜º [0m 

269) (lambda (a b) (lambda (c) (+ a b c)))
[1;32m Success! â˜º [0m 

270) (define fact (lambda (n) (if (zero? n) 1 (* n (fact (- n 1))))))
[1;32m Success! â˜º [0m 

271) (lambda (a b) c d (lambda () c d))
[1;32m Success! â˜º [0m 

272) (x (lambda (x) (x (lambda () (x (lambda () (x x)))))))
[1;32m Success! â˜º [0m 

273) (f (lambda (a b) (lambda (c) a (lambda () (lambda (d) (lambda x a))))))
[1;32m Success! â˜º [0m 

274) ((lambda (a) (begin a (lambda () a) (lambda (a) a))))
[1;32m Success! â˜º [0m 

275) (f (g (h (a (b (abc (lambda () a (lambda () (lambda () b)))))))))
[1;32m Success! â˜º [0m 

276) (lambda (a b) (lambda (c) a (lambda () b (lambda (d) c))))
[1;32m Success! â˜º [0m 

277) (lambda (a b) (lambda (c) a (lambda () b)))
[1;32m Success! â˜º [0m 

278) (lambda () a (lambda () (lambda () b)))
[1;32m Success! â˜º [0m 

279) ((lambda (a) a) (lambda (b) b) (lambda (c) c) d)
[1;32m Success! â˜º [0m 

280) (lambda (a b) (lambda (c) a))
[1;32m Success! â˜º [0m 

281) (a (lambda a a) (lambda (a) a) a (lambda (a) (lambda () a) a))
[1;32m Success! â˜º [0m 

282) ((lambda (a) a) (lambda (b) b d) (lambda (c) c))
[1;32m Success! â˜º [0m 

283) (lambda (+) (+ 1 2))
[1;32m Success! â˜º [0m 

284) (lambda a a)
[1;32m Success! â˜º [0m 

285) (lambda (a b) a (lambda (b . c) b))
[1;32m Success! â˜º [0m 

286) (lambda () (+ 1 2))
[1;32m Success! â˜º [0m 

287) (lambda (a) a)
[1;32m Success! â˜º [0m 

288) (lambda (a b) a c (lambda (a . b) b))
[1;32m Success! â˜º [0m 

289) (let ((a 0) (c 1)) (list (lambda () a) (lambda () (set! a (+ a 1))) (lambda (b) (set! a b)) (lambda () c) (lambda () (set! c (+ a 1))) (lambda (b) (set! c b))))
[1;32m Success! â˜º [0m 

290) (lambda (a b) (begin a (set! a b) (lambda () a) (lambda (a b) (+ a b))))
[1;32m Success! â˜º [0m 

291) (define mileage (lambda (thunk) (let ((loop ((eng (make-engine thunk)) (total-ticks 0)))) (eng 50 (lambda (ticks value) (+ total-ticks (- 50 ticks))) (lambda (new-eng) (loop new-eng (+ total-ticks 50)))))))
[1;32m Success! â˜º [0m 

292) (define round-robin (lambda (engs) (if (null? engs) (quote ()) ((car engs) 1 (lambda (ticks value) (cons value (round-robin (cdr engs)))) (lambda (eng) (round-robin (append (cdr engs) (list eng))))))))
[1;32m Success! â˜º [0m 

293) (lambda (a . b) (begin (lambda () a) (set! a 5)))
[1;32m Success! â˜º [0m 

294) 1
[1;32m Success! â˜º [0m 

295) (lambda (a . b) a)
[1;32m Success! â˜º [0m 

296) (lambda (a . b) (lambda () a))
[1;32m Success! â˜º [0m 

297) (let ((a 0)) (list (lambda () a) (lambda () (set! a (+ a 1))) (lambda (b) (set! a b))))
[1;32m Success! â˜º [0m 

298) (let* ((c 0) (a (box c))) (list (lambda () a) (lambda () (set! a (+ a 1))) (lambda (b) (set! a b))))
[1;32m Success! â˜º [0m 

299) (lambda (x . y) (lambda (x) y x (set! x 1) (* x 1)))
[1;32m Success! â˜º [0m 

300) (lambda (x) x (f (lambda (y) (define a 5) y)))
[1;32m Success! â˜º [0m 

301) (lambda (x) (lambda (y) (lambda (z) (define x 1) (define y 2) (define z 3) y)))
[1;32m Success! â˜º [0m 

302) (lambda (x . y) 1)
[1;32m Success! â˜º [0m 

303) (lambda (x) ((f (lambda (z) z)) (lambda (y) y)))
[1;32m Success! â˜º [0m 

304) (lambda (x) (lambda (y) (lambda (z) z)))
[1;32m Success! â˜º [0m 

305) (even? e)
[1;32m Success! â˜º [0m 

306) (lambda x (lambda (a . b) a (lambda (b) b c (f (lambda (y) (define a 5) a)))))
[1;32m Success! â˜º [0m 

307) (define my-even? (lambda (e) (define even? (lambda (n) (or (zero? n) (odd? (- n 1))))) #t))
[1;32m Success! â˜º [0m 

308) (define odd? (lambda (n) (and (positive? n) (even? (- n 1)))))
[1;32m Success! â˜º [0m 

309) (lambda (z) (define a 5) (define b 123) (lambda (y) (define x 10) (define x1 (lambda (abc) (define a 56) (define x1 10) (+ 1 2))) (f 32 45 (quote a))) (a 5))
[1;32m Success! â˜º [0m 

310) (define x (lambda (x) x))
[1;32m Success! â˜º [0m 

311) (lambda (x) (define a 5) (define a1 123) (lambda (y) (define x 10) (a 5)) 2)
[1;32m Success! â˜º [0m 

312) (lambda (x) (define a 5) (lambda () (define a 123) (a #t)) (lambda (y) (define x 10) (a 5)) 2)
[1;32m Success! â˜º [0m 

313) (lambda (x) (define y (lambda () (define a 5) 4)) 1)
[1;32m Success! â˜º [0m 

314) (lambda (x) (define a 5) (lambda (y) (define x 10) (a 5)))
[1;32m Success! â˜º [0m 

315) (lambda (x) (define a 5) b)
[1;32m Success! â˜º [0m 

316) (lambda (x) (lambda (y) (define x 10) (a 5)))
[1;32m Success! â˜º [0m 

317) (lambda (a b c d e) ((lambda (a b c) (lambda (z e1) (e1 5))) 5 6 7))
[1;32m Success! â˜º [0m 

318) (lambda (a b c d e) ((lambda (a b c) (lambda () 5))))
[1;32m Success! â˜º [0m 

319) (lambda (x y) (lambda (a b c) a b c) x y)
[1;32m Success! â˜º [0m 

320) (lambda (x y) ((lambda (a b c) a b c) 5 6 7) x y)
[1;32m Success! â˜º [0m 

321) (lambda (x) x)
[1;32m Success! â˜º [0m 

322) (lambda (x y) x y (lambda (a b c) a b c))
[1;32m Success! â˜º [0m 


[1;32m"Complex Tests" Tests: SUCCESS! â˜º [0m
 
Summary
=============================
[1;32mPassed: 322 of 322 tests â˜º[0m
[1;32m!!!!!  â˜º  ALL TESTS SUCCEEDED  â˜º  !!!![0m

> 
